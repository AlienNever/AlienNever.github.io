[{"title":"自己写的一些python代码","date":"2018-03-05T04:00:00.000Z","path":"2018/03/05/04-20180305/","text":"AlienDB数据库操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# -*- coding:utf-8 -*-import pymysqlimport cx_Oracleimport osos.environ[&apos;NLS_LANG&apos;]=&apos;SIMPLIFIED CHINESE_CHINA.UTF8&apos;class DBManager(): def __init__(self, dbtype,dbhost,dbname,username,password): self.__dbtype=dbtype self.__dbhost=dbhost self.__dbname=dbname self.__username=username self.__password=password self.__connection=self.getConnection() self.__cursor=self.__connection.cursor() def getConnection(self): try: if self.__dbtype == &apos;mysql&apos;: connection = pymysql.connect(self.__dbhost,self.__username,self.__password,self.__dbname) elif self.__dbtype == &apos;oracle&apos;: connection = cx_Oracle.connect(&apos;&#123;0&#125;/&#123;1&#125;@&#123;2&#125;/&#123;3&#125;&apos;.format(self.__username,self.__password,self.__dbhost,self.__dbname)) else: print (&quot;当前不支持该数据库&quot;) return except Exception as err: print (&quot;连接数据库失败&#123;0&#125;&quot;.format(err)) else: print (&quot;连接数据库成功&quot;) return connection def query(self,sql): try: self.__cursor.execute(sql) fields=self.__cursor.description res=list(self.__cursor.fetchall()) fieldlist=[] for filed in range(len(fields)): fieldlist.append(fields[filed][0]) for item in res: print(item) print (&quot;total rows:&#123;0&#125;&quot;.format(self.__cursor.rowcount)) except Exception as err: print(&quot;查询失败&#123;0&#125;&quot;.format(err)) else: return (fieldlist,res) #返回一个自定义二元组tableTuple，元组第一个元素为table的字段列表，第二个元素为查询结果列表 def update(self,sql): try: self.__cursor.execute(sql) self.__connection.commit() print (&quot;changed rows:&#123;0&#125;&quot;.format(self.__cursor.rowcount)) print (&quot;执行成功！&quot;) except Exception as e: self.__connection.rollback() print (&quot;执行失败！&quot;) def close(self): try: self.__cursor.close() self.__connection.close() print (&quot;数据库连接关闭成功！&quot;) except Exception as e: print (&quot;数据库连接关闭失败！&quot;) AlienExcel表格操作1234567891011121314151617181920212223242526272829303132333435import xlrdimport xlwtclass ExcelManager(): def __init__(self,dir): self.__dir=dir; def printExcel(self,dir): try: workbook=xlrd.open_workbook(dir) sheet_names=workbook.sheet_names() for sheet_name in sheet_names: sheet=workbook.sheet_by_name(sheet_name) print (sheet_name+&apos;\\n&apos;) for row in range(sheet.nrows): for col in range(sheet.ncols): print (sheet.cell(row,col).value,end=&quot; &quot;) print (&quot;\\n&quot;) except Exception as err: print (&quot;打印失败：&#123;0&#125;&quot;.format(err)) def tableTupleToExcel(self,tableTuple,sheetName): #将tabaleTuple元素转换为Excel表格，写出只支持.xls格式 try: workbook=xlwt.Workbook(encoding=&quot;utf-8&quot;) worksheet=workbook.add_sheet(sheetName) fieldlist,datalist=tableTuple[0],tableTuple[1] rows,cols=len(datalist),len(fieldlist) for i in range(cols): worksheet.write(0,i,fieldlist[i]) for j in range(1,rows+1): worksheet.write(j,i,datalist[j-1][i]) workbook.save(self.__dir+r&apos;\\&#123;0&#125;.xls&apos;.format(sheetName)) print (&quot;生成excel文件成功&quot;) except Exception as err: print (&quot;生成excel文件失败：&#123;0&#125;&quot;.format(err)) AlienEmail邮箱操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import osimport smtplibfrom email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultipartfrom email.header import Headerclass EmailManager(): def __init__(self,mail_username,mail_password,mail_from,mail_to,mail_att=&apos;&apos;,mail_host=&apos;smtp.sgcc.com.cn&apos;,mail_cc=&apos;&apos;,mail_subject=&apos;&apos;,mail_body=&apos;&apos;,mail_port=25): self.__mail_host=mail_host; self.__mail_port=mail_port; self.__mail_username=mail_username; self.__mail_password=mail_password; self.__mail_from=mail_from; self.__mail_to=mail_to; self.__mail_cc=mail_cc; self.__mail_subject=mail_subject; self.__mail_body=mail_body; self.__mail_att=mail_att; self.__mail_body_inscribe=&quot;\\r\\n\\r\\n\\r\\n\\r\\n---------\\r\\n; def genMailContent(self): try: message=MIMEMultipart() message[&apos;From&apos;]=Header(self.__mail_from,&apos;utf-8&apos;) message[&apos;To&apos;]=Header(self.__mail_to,&apos;utf-8&apos;) message[&apos;Subject&apos;]=Header(self.__mail_subject,&apos;utf-8&apos;) message.attach(MIMEText(self.__mail_body+self.__mail_body_inscribe,&apos;plain&apos;,&apos;utf-8&apos;)) if self.__mail_att!=&apos;&apos;: self.genMailAttachment(message,self.__mail_att) except Exception as err: print (&quot;生成邮件失败:&#123;0&#125;&quot;.format(err)) else: print(&quot;生成邮件成功&quot;) return message def genMailAttachment(self,message,path): try: if os.path.isfile(path): filename=os.path.split(path) att=MIMEText(open(path,&quot;rb&quot;).read(),&apos;base64&apos;,&apos;utf-8&apos;) att[&apos;Content-Type&apos;]=&apos;application/octet-stream&apos; att.add_header(&quot;Content-Disposition&quot;,&quot;attachment&quot;,filename=(&quot;utf-8&quot;,&quot;&quot;,&quot;&#123;0&#125;&quot;.format(filename[1]))) message.attach(att) elif os.path.exists(path): attTuple=os.listdir(path) for attfile in attTuple: if os.path.isfile(os.path.join(path,attfile)): att=MIMEText(open(os.path.join(path,attfile),&quot;rb&quot;).read(),&apos;base64&apos;,&apos;utf-8&apos;) att[&apos;Content-Type&apos;]=&apos;application/octet-stream&apos; att.add_header(&quot;Content-Disposition&quot;,&quot;attachment&quot;,filename=(&quot;utf-8&quot;,&quot;&quot;,&quot;&#123;0&#125;&quot;.format(attfile))) message.attach(att) print (&quot;附件添加成功&quot;) except Exception as err: print (&quot;附件添加失败:&#123;0&#125;&quot;.format(err)) def sendEmail(self): try: mailContent=self.genMailContent() smtpObj=smtplib.SMTP() smtpObj.connect(self.__mail_host,self.__mail_port) smtpObj.login(self.__mail_username,self.__mail_password) smtpObj.sendmail(self.__mail_from,self.__mail_to,mailContent.as_string()) print (&quot;邮件发送成功&quot;) except smtplib.SMTPException as e: print(&quot;邮件发送失败:&#123;0&#125;&quot;.format(e)) finally: smtpObj.quit()","tags":[{"name":"Pyhton","slug":"Pyhton","permalink":"https://aliennever.github.io/tags/Pyhton/"}]},{"title":"Linux虚拟机安装","date":"2018-03-01T04:00:00.000Z","path":"2018/03/01/03-20180301/","text":"系统安装： 最小化安装： 打开VMware，新建虚拟机&gt;典型配置&gt;稍后安装操作系统&gt;Linux&gt;选择存储文件夹&gt;设置虚拟机磁盘容量&gt;完成 CD/DVD选择Linux系统镜像文件&gt;开启虚拟机&gt;Install Linux&gt;安装语言选择简体中文&gt;设定时间、配置分区(规划可以如下图)、配置网络&gt;网络和主机名选择连接&gt;设置root用户密码 安装桌面环境： 打开VMware,在CD/DVD设置选项中，将Redhat7镜像文件放入CD/DVD中 root用户下将虚拟光驱挂载到 /mnt 文件夹下 （确保虚拟光驱处于链接状态） 12[root@localhost ~]# mount /dev/sr0 /mntmount: /dev/sr0 is write-protected, mounting read-only 配置光盘为本地yum源 123456[root@localhost ~]# vi /etc/yum.repos.d/local.repo[local]name=localbaseurl=file:///mntenabled=1gpgcheck=0 查看组yum包\\安装桌面环境组件\\切换到图形化界面 123[root@localhost ~]# yum grouplist[root@localhost ~]# yum groupinstall -y &quot;Server with GUI&quot;[root@localhost ~]# startx 默认启动模式查看与切换 查看当前启动模式： systemctl get-default 桌面启动：systemctl set-default graphical.target 命令行启动：systemctl set-default multi-user.target 安装VMware tools: 虚拟机 &gt;&gt;客户机 &gt;&gt; 安装/升级 VMware Tools 挂载解压资源 1234567[root@localhost /]# cd /media/[root@localhost media]# mount /dev/cdrom /media mount: /dev/sr0 is write-protected, mounting read-only[root@localhost media]# cp VMwareTools-10.0.10-4301679.tar.gz /tmp[root@localhost media]# cd /tmp[root@localhost tmp]# chmod +x VMwareTools-10.0.10-4301679.tar.gz[root@localhost tmp]# tar zxf VMwareTools-10.0.10-4301679.tar.gz 安装并卸载CD-ROM 1234[root@localhost tmp]# cd vmware-tools-distrib/[root@localhost vmware-tools-distrib]# ./vmware-install.pl[root@localhost vmware-tools-distrib]# cd /[root@localhost /]# umount /media","tags":[{"name":"Linux","slug":"Linux","permalink":"https://aliennever.github.io/tags/Linux/"}]},{"title":"weblogic集群配置","date":"2018-02-26T04:00:00.000Z","path":"2018/02/26/02-20180226/","text":"一、相关概念 服务器(Server): AdminServer：主要用于管理，包括应用部署，动态创建server，以及各种服务配置.所以集群环境下不会将应用、数据源等服务部署到AdminServer上面，因为AdminServer仅仅是充当管理者角色而已。运维过程中，还起到监控其它服务器状态的作用。 PorxyServer：主要受理各种外部请求，做负载均衡，将具体工作交给具体的服务器。所以集群环境下，也不会将应用部署到ProxyServer上。除weblogic自带负载均衡方式外，也可用Apache\\Nginx软负载或者F5硬负载等方式部署。 Server: 实际处理业务请求的服务器，把前段代理服务器上接受到的任务进行实际处理，处理完了反馈给客户端。 AdminServer只负责管理、ProxyServer负责受理分配、而普通的Server就负责处理业务请求。 集群(cluster):控制台里面配置的集群，仅仅用于设置server之间的多播通信。server之间使用多播通信，互相告诉自己状态是否可用。 计算机(machine):可选配置：控制台里面配置的计算机，仅仅用于配置“节点管理器”信息（地址、端口）。然后根据配置信息向节点管理器发送操作命令。 节点管理器(nodemanager):可选服务：节点管理器在集群架构中，不是必须的。它的作用是用来管理server的生命周期，如果没有使用节点管理器，那么集群中的所有server的启动、关闭等常用的操作，必须通过运行startManagedWebLogic.cmd\\stopManagedWebloigc.cmd脚本来完成(脚本路径：D:\\Oracle\\Middleware\\user_projects\\domains\\base_domain\\bin)。例如启动server1: 1234startManagedWebLogic server1 127.0.0.1:7001server1 启动的受管服务器的名称 address 该域的管理服务器的IP地址 port 该域的管理服务器的监听端口 所以有些集群环境下，你能看到有多少个server，就有多少个启动脚本，实际上就是执行上面这个命令。如果集群中的server分布在多台主机上面，那每次启动服务非常不方便，所以这时候，节点管理器就派上用场了，节点管理器负责管理本机server的启动、关闭等生命周期。 二、单机单域集群部署实例: 部署规划： 运行Server 主机Ip 访问port AdminServer 172.16.92.41 7001 PorxyServer 172.16.92.41 17000 Server1 172.16.92.41 17001 Server2 172.16.92.41 17002 其中AdminServer是总控制端，ProxyServer为负载分发代理服务器，server1、server2是集群中的两个服务节点。 创建服务器\\集群\\计算机: 登录weblogic控制台:通过域目录下startWebLogic脚本启动weblogic服务，浏览器localhost:7001/console进入weblogic控制台。 建立服务器(Sever):域结构&gt;环境&gt;服务器：分别输入ip\\port建立Server1\\Server2\\PorxyServer 建立集群(cluster)域结构&gt;环境&gt;集群：建立Cluster1，消息传送模式选多点传送，传送地址和端口默认。建好后点击Cluster1超链接&gt;服务器选项卡将Sever1\\Sever2加入到集群中。 建立计算机(machine):域结构&gt;环境&gt;计算机：建立Machine1,默认配置，建好后点击Machine1超链接&gt;服务器选项卡将Sever1\\Sever2\\PorxyServer加入到集群中。 部署服务：域结构&gt;部署：分别选择相应的项目路径部署Proxy项目和MyProject项目，MyProject项目为自建测试项目(若有数据源需要在域结构&gt;服务&gt;数据源中配置数据源)，Proxy项目为weblogic自带负载分发项目，只在WEB-INF目录下包含web.xml和weblogic.xml，相应代码如下： web.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt; &lt;display-name&gt;WeblogicProxy&lt;/display-name&gt; &lt;!-- 配置web的servlet，拦截所有的请求，proxy内部会检测server的状态、负载情况，然后根据算法再将请求转发给具体的server处理 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;HttpClusterServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;weblogic.servlet.proxy.HttpClusterServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;WebLogicCluster&lt;/param-name&gt; &lt;param-value&gt;172.16.92.41:17001|172.16.92.41:17002&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;DebugConfigInfo&lt;/param-name&gt; &lt;param-value&gt;ON&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;verbose&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HttpClusterServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HttpClusterServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HttpClusterServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HttpClusterServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;*.htm&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HttpClusterServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;*.html&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HttpClusterServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jpd&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HttpClusterServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jcx&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HttpClusterServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;*.dtf&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HttpClusterServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jws&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; weblogic.xml 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;wls:weblogic-web-app xmlns:wls=&quot;http://xmlns.oracle.com/weblogic/weblogic-web-app&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd http://xmlns.oracle.com/weblogic/weblogic-web-app http://xmlns.oracle.com/weblogic/weblogic-web-app/1.3/weblogic-web-app.xsd&quot;&gt; &lt;wls:weblogic-version&gt;10.3.6&lt;/wls:weblogic-version&gt; &lt;wls:context-root&gt;/&lt;/wls:context-root&gt;&lt;/wls:weblogic-web-app&gt; 启动服务器节点 修改D:\\Oracle\\Middleware\\wlserver_10.3\\common\\nodemanager目录下nodemanager.properties 字段，将默认的ListenAddress=localhost D:\\Oracle\\Middleware\\wlserver_10.3\\server\\bin目录下的脚本installNodeMgrSvc.cmd，然后在计算机&gt;管理&gt;服务启动Oracle WebLogic NodeManager (D_Oracle_Middleware_wlserver_10.3)服务 进入weblogic控制台界面，选择服务器&gt;控制选项卡，勾选对应的托管服务器，就可以进行启动关闭等操作。 三、双机集群部署实例： 前期注意： 集群中的所有Server必须位于同一网段，并且必须是IP广播(UDP)可到达的; 集群中的所有Server必须使用相同的版本,包括 Service Pack; 集群中的Server必须使用永久的静态IP地址。动态IP 地址分配不能用于集群环境。如果服务器位于防火墙后面，而客户机位于防火墙外面，那么服务器必须有公共的静态IP地址，只有这样，客户端才能访问服务器; 部署规划： 运行Server 主机Ip 访问port AdminServer 172.16.92.41 7001 ProxyServer 172.16.92.41 17000 Server1 172.16.92.41 17001 Server2 172.16.92.42 17001 创建域： 172.16.92.41: 启动weblogic配置向导，创建weblogic域，选择可选配置选项卡选择’管理服务器’和’受管理服务器，集群和计算机’两个选项，依照上述规划进行建立。 启动weblogic控制台，登录管理服务，安装部署应用及代理服务.配置Jndi数据源。以上步骤注意地址一定输入准确的IP地址不要使用localhost！管理服务AdminServer监听地址为空！若本机有虚拟网卡需要禁用！ 172.16.92.42：启动weblogic配置向导，创建weblogic域，选择可选配置选项卡选择’管理服务器’和’受管理服务器，集群和计算机’两个选项，管理服务器IP选择172.16.92.41服务器名建立要与172.16.92.41上建立的相匹配(即Server2)，集群和计算机不用配置。 部署服务：分别选择相应的项目路径部署Proxy项目和MyProject项目，程序中调用Jndi时也需要使用准确的IP地址！","tags":[{"name":"weblogic","slug":"weblogic","permalink":"https://aliennever.github.io/tags/weblogic/"}]},{"title":"weblogic删除域","date":"2018-02-26T04:00:00.000Z","path":"2018/02/26/01-20180226/","text":"以weblogic主目录路径为：D:\\Oracle\\Middleware，删除域名为base_domain的域为例 删除D:\\Oracle\\Middleware\\user_projects\\domains下的base_domain整个文件夹 删除开始菜单中Oracle Welogic\\User Projects下的base_domain整个文件夹 删除D:\\Oracle\\Middleware\\wlserver_10.3\\common\\nodemanager\\nodemanager.domains里的base_domain域内容 1234#Domains and directories created by Configuration Wizard#Sat Feb 24 08:48:09 CST 2018deve_domain=D\\:\\\\Oracle\\\\Middleware\\\\user_projects\\\\domains\\\\deve_domainbase_domain=D\\:\\\\Oracle\\\\Middleware\\\\user_projects\\\\domains\\\\base_domain 删除以上base_domain一行 删除 D:\\Oracle\\Middleware\\domain-registry.xml 里的base_domain域内容 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;domain-registry xmlns=&quot;http://xmlns.oracle.com/weblogic/domain-registry&quot;&gt;&lt;domain location=&quot;D:\\Oracle\\Middleware\\user_projects\\domains\\deve_domain&quot;/&gt;&lt;domain location=&quot;D:\\Oracle\\Middleware\\user_projects\\domains\\base_domain&quot;/&gt;&lt;/domain-registry&gt; 删除以上base_domain一行 附一个删除脚本：12345678910111213141516171819202122232425262728293031323334353637383940414243import osimport shutilimport redef deleteDomain(domainName): domainPath=r&apos;D:\\Oracle\\Middleware\\user_projects\\domains&apos; startMenuPath=r&apos;C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Oracle WebLogic\\User Projects&apos; nodemanagerPath=r&apos;D:\\Oracle\\Middleware\\wlserver_10.3\\common\\nodemanager\\nodemanager.domains&apos; nodemanagerPathNew=r&apos;D:\\Oracle\\Middleware\\wlserver_10.3\\common\\nodemanager\\nodemanagertemp.domains&apos; domainRegistryPath=r&apos;D:\\Oracle\\Middleware\\domain-registry.xml&apos; domainRegistryPathNew=r&apos;D:\\Oracle\\Middleware\\domain-registrytemp.xml&apos; if domainName.strip()!=&apos;&apos;: try: deleteDomainPath=os.path.join(domainPath,domainName) deleteStartMenuPath=os.path.join(startMenuPath,domainName) if os.path.isdir(deleteDomainPath): shutil.rmtree(deleteDomainPath) print (&quot;删除域目录成功！&quot;) else: print (&quot;域目录不存在！&quot;) if os.path.isdir(deleteStartMenuPath): shutil.rmtree(deleteStartMenuPath) print (&quot;删除域开始菜单成功！&quot;) else: print (&quot;域开始菜单目录不存在！&quot;) with open(nodemanagerPath, &apos;r&apos;) as f: with open(nodemanagerPathNew, &apos;w&apos;) as g: for line in f.readlines(): if not re.match(domainName,line): g.write(line) os.remove(nodemanagerPath) os.rename(nodemanagerPathNew,nodemanagerPath) with open(domainRegistryPath, &apos;r&apos;) as f: with open(domainRegistryPathNew, &apos;w&apos;) as g: for line in f.readlines(): if not re.search(domainName,line): g.write(line) os.remove(domainRegistryPath) os.rename(domainRegistryPathNew,domainRegistryPath) except Exception as err: print (&quot;删除域失败：&#123;0&#125;&quot;.format(err)) else: print (&quot;域名输入有误！&quot;)","tags":[{"name":"weblogic","slug":"weblogic","permalink":"https://aliennever.github.io/tags/weblogic/"}]}]